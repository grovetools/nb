package cmd

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/mattsolo1/grove-core/git"
	grovelogging "github.com/mattsolo1/grove-core/logging"
	"github.com/mattsolo1/grove-notebook/pkg/service"
	"github.com/spf13/cobra"
)

var gitUlog = grovelogging.NewUnifiedLogger("grove-notebook.cmd.git")

// NewGitCmd creates the `nb git` command and its subcommands.
func NewGitCmd(svc **service.Service, workspaceOverride *string) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "git",
		Short: "Manage Git repositories within notebook directories",
		Long:  `Provides commands for initializing and managing Git repositories directly within notebook storage locations.`,
	}

	cmd.AddCommand(newGitInitCmd(svc, workspaceOverride))
	cmd.AddCommand(newGitCommitCmd(svc, workspaceOverride))
	return cmd
}

func newGitInitCmd(svc **service.Service, workspaceOverride *string) *cobra.Command {
	var globalRepo bool
	var rootRepo bool

	cmd := &cobra.Command{
		Use:   "init",
		Short: "Initialize a Git repository in the current workspace's notebook directory",
		Long: `Initializes a Git repository in the notebook workspace directory for the current context.

This command performs three actions:
1. Runs 'git init' in the target notebook directory.
2. Creates a '.gitignore' file with sensible defaults for notebook content.
3. Creates a '.grove/notebook.yml' marker file to identify this as a notebook repository.

Target directory options:
- Default: Current workspace's notebook directory (e.g., workspaces/my-project/)
- --global: The global notebook directory (global/)
- --root: The entire notebook root containing all workspaces`,
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx := context.Background()
			s := *svc

			// Validate flags are mutually exclusive
			if globalRepo && rootRepo {
				return fmt.Errorf("--global and --root flags are mutually exclusive")
			}

			// 1. Determine Target Directory
			var targetCtx string
			if globalRepo {
				targetCtx = "global"
			} else {
				targetCtx = *workspaceOverride
			}

			wsCtx, err := s.GetWorkspaceContext(targetCtx)
			if err != nil {
				return fmt.Errorf("getting workspace context: %w", err)
			}

			// Get the workspace directory from the paths.
			// The structure is .../workspaces/<name>/inbox, so the workspace dir is one level up from inbox.
			locator := s.GetNotebookLocator()
			samplePath, err := locator.GetNotesDir(wsCtx.NotebookContextWorkspace, "inbox")
			if err != nil {
				return fmt.Errorf("could not resolve notebook path: %w", err)
			}
			// Go up one level from inbox to get the workspace directory
			targetDir := filepath.Dir(samplePath)

			// If --root flag is set, find the notebook root directory
			if rootRepo {
				// From workspace dir, go up to find the notebook root.
				// Structure: <root>/workspaces/<name>/ or <root>/global/
				parent := filepath.Dir(targetDir)
				parentName := filepath.Base(parent)
				if parentName == "workspaces" {
					// We're in a workspace, go up one more level
					targetDir = filepath.Dir(parent)
				} else {
					// We're in global or similar, parent is the root
					targetDir = parent
				}
			}

			gitUlog.Info("Targeting notebook directory").
				Field("target_dir", targetDir).
				Pretty(fmt.Sprintf("Targeting notebook directory: %s", targetDir)).
				PrettyOnly().
				Log(ctx)

			// 2. Initialize Git Repository
			gitDir := filepath.Join(targetDir, ".git")
			if _, err := os.Stat(gitDir); err == nil {
				gitUlog.Info("Git repository already initialized").
					Field("target_dir", targetDir).
					Pretty("Git repository already initialized.").
					PrettyOnly().
					Log(ctx)
			} else {
				gitCmd := exec.Command("git", "init")
				gitCmd.Dir = targetDir
				if output, err := gitCmd.CombinedOutput(); err != nil {
					return fmt.Errorf("git init failed: %w\n%s", err, string(output))
				}
				gitUlog.Success("Git repository initialized").
					Field("target_dir", targetDir).
					Pretty("✓ Git repository initialized.").
					PrettyOnly().
					Log(ctx)
			}

			// 3. Create .gitignore
			gitignorePath := filepath.Join(targetDir, ".gitignore")
			gitignoreContent := `# Generated by nb git init
.artifacts/
.grove-worktrees/
.grove/

# OS files
.DS_Store
Thumbs.db

# Editor files
*.swp
.idea/
.vscode/
`
			if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
				return fmt.Errorf("failed to write .gitignore: %w", err)
			}
			gitUlog.Success("Created .gitignore").
				Field("target_dir", targetDir).
				Field("gitignore_path", gitignorePath).
				Pretty("✓ Created/updated .gitignore.").
				PrettyOnly().
				Log(ctx)

			// 4. Create notebook.yml Marker (at top level)
			markerContent := fmt.Sprintf("type: notebook\ncreated: %s\n", time.Now().Format(time.RFC3339))
			if err := os.WriteFile(filepath.Join(targetDir, "notebook.yml"), []byte(markerContent), 0644); err != nil {
				return fmt.Errorf("failed to create notebook marker: %w", err)
			}
			gitUlog.Success("Created notebook marker").
				Field("target_dir", targetDir).
				Pretty("✓ Created notebook.yml marker file.").
				PrettyOnly().
				Log(ctx)

			gitUlog.Success("Notebook initialized with Git").
				Field("target_dir", targetDir).
				Pretty("\nSuccess! Your notebook is now under Git version control.").
				PrettyOnly().
				Log(ctx)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&globalRepo, "global", "g", false, "Initialize in the global notebook directory")
	cmd.Flags().BoolVarP(&rootRepo, "root", "r", false, "Initialize in the notebook root (all workspaces in one repo)")
	return cmd
}

func newGitCommitCmd(svc **service.Service, workspaceOverride *string) *cobra.Command {
	var message string

	cmd := &cobra.Command{
		Use:   "commit [files...]",
		Short: "Stage and commit changes in the current notebook's repository",
		Long: `Convenience command to stage and commit changes in the notebook repository.
If no files are specified, all changes are staged.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx := context.Background()
			s := *svc

			// 1. Determine the notebook directory for the current context.
			wsCtx, err := s.GetWorkspaceContext(*workspaceOverride)
			if err != nil {
				return fmt.Errorf("getting workspace context: %w", err)
			}

			// We need a path inside the notebook to find the git root.
			// Using the 'inbox' directory is a reliable way to get a path.
			inboxPath, err := s.GetNotebookLocator().GetNotesDir(wsCtx.NotebookContextWorkspace, "inbox")
			if err != nil {
				return fmt.Errorf("could not resolve notebook path: %w", err)
			}

			// 2. Find the root of the git repository.
			gitRoot, err := git.GetGitRoot(inboxPath)
			if err != nil {
				return fmt.Errorf("notebook directory is not a git repository. Run 'nb git init'")
			}

			// 3. Stage files.
			stageArgs := []string{"add"}
			if len(args) > 0 {
				stageArgs = append(stageArgs, args...)
			} else {
				stageArgs = append(stageArgs, ".")
			}

			gitAddCmd := exec.Command("git", stageArgs...)
			gitAddCmd.Dir = gitRoot
			if output, err := gitAddCmd.CombinedOutput(); err != nil {
				return fmt.Errorf("git add failed: %w\n%s", err, string(output))
			}
			gitUlog.Success("Staged changes").
				Field("git_root", gitRoot).
				Field("files", args).
				Pretty("✓ Staged changes.").
				PrettyOnly().
				Log(ctx)

			// 4. Commit changes.
			if message == "" {
				message = "Update notes"
			}
			gitCommitCmd := exec.Command("git", "commit", "-m", message)
			gitCommitCmd.Dir = gitRoot
			if output, err := gitCommitCmd.CombinedOutput(); err != nil {
				// Don't error if there's nothing to commit.
				if strings.Contains(string(output), "nothing to commit") {
					gitUlog.Info("No changes to commit").
						Field("git_root", gitRoot).
						Pretty("No changes to commit.").
						PrettyOnly().
						Log(ctx)
					return nil
				}
				return fmt.Errorf("git commit failed: %w\n%s", err, string(output))
			}

			gitUlog.Success("Committed changes").
				Field("git_root", gitRoot).
				Field("message", message).
				Pretty(fmt.Sprintf("✓ Committed with message: \"%s\"", message)).
				PrettyOnly().
				Log(ctx)
			return nil
		},
	}

	cmd.Flags().StringVarP(&message, "message", "m", "", "Commit message (default: \"Update notes\")")
	return cmd
}
